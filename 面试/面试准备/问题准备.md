# 1. css兼容性问题
处理的常规方法有 _ * \9 或者css  IE hack  if <!–[if lt IE 7 ]&gt;&lt;![endif]–>  不过常规的用法更更多的是利用浏览器之间对css的支持差异去优雅的解决问题。
有时候重要的不是技巧本身，而是解决问题的思路，以及自己的脑洞。以后，大家如果需要做一些向下兼容的处理，不妨就试试这种利用属性值兼容性实现的兼容技巧，完全不影响权重，不干扰正常的CSS复杂度。
```
/*例子：阴影的兼容
box-shadow   IE9+才兼容    (可以用border (IE6+) 去代替*/

/*一般写法*/
.box {
    border: 1px solid #ddd;
}
:root box {
    border: 0 none;
    box-shadow: 0 1px 3px rgba(0,0,0,.25);
}

/*好的写法  利用rgba 只有ie9+才认识*/
.box {
    box-shadow: 0 1px 3px rgba(0,0,0,.25);
    border: 1px solid #d0d0d5;
    border: 0 rgba(0,0,0,.2);
}
```

# 3. js引擎 微任务宏任务
js是有一个执行栈的，他有同步任务和异步任务，
如果执行到同步任务，会把他放到执行栈里面去执行，
如果执行到异步任务，会把它放到任务队列里面，等到把同步任务执行完之后会去任务队列里面读取异步任务。

任务队列里面   有宏任务(异步请求setTimeOut等)和微任务(promise/MutationObserver和Process.nextTick/setImmediate)
同步任务执行完会检查有没有待执行的异步任务，
如果有微任务会一次性执行完所有的微任务
微任务执行完后执行待执行的宏任务，宏任务执行完后，进行下一轮的同步任务。
跟node的事件轮询最大的区别是这点，
node是宏任务微任务穿插执行
node11以上 跟js一样
js会把所有的微任务执行完之后 在去执行宏任务

# 4. 浏览器工作原理

domTreee  CSSOMTree  LayerOutTree  paint 合成

# 如何做性能优化  navigation-timing
总的痛点是解决：
- 网络延迟 以小为原则，按照，根据雅虎军规的方式挨个去做优化
- 渲染瓶颈 渲染:主要是解决重绘和重排，图块分层，尽量让GPU参与，让重绘局部化  内存：业务代码的优化，减少内存开销
**缓存**
浏览器缓存
http缓存
**网络优化**
1. CDN
2. 响应压缩
3. http2
4. node做中间层  加大网络并发
5. mp2做node容器，开启多线程，较少宕机
6. nginx做负载均衡，压缩gz br，http2
**渲染** RAIL  SSR PWA
被动渲染
1. webpack优化  压缩，摇树，分包
2. webpack 路径优化，CDN配置，图片优化，按需加载
3. 图片资源的优化，雪碧图，字体图标，小体积图片base64
主动响应优化
1. css读写分离
2. 通过class或者style.csstext做样式批量想改
3. 减少dom的深度，多用伪元素，或者box-shadow代替
4. documentFragment离线dom更新
5. display：none|visbility:hidden
6. 滚动可见   InterSectionObserve
7. 图片渲染指定大小
8. JS主线程调度：时间分片，worker，requestDleCallback,requestAnimationFrame,
9. 开启分层，尽量让GPU参与，让重绘局部化，transform
10. 虚拟dom
**代码层面**

**测试工具**
LCP 2.5~4s FID100-300 CLS 0.1-0.25  TTFB FP FCP FMP TTI
1. Page Speed  网络请求测试工具，有分析性报告和提议
2. lightHouse  综合性的测试，性能，可拓展，实践，SEO，PWA
3. Profile  node-inspector 对node的调试和内存和cpu的监控
4. 谷歌本身的调试  performace  Performance.timingAPI timeLine调试关键帧渲染情况，rendering观察重排和重绘的情况   profiles 观察内存占比

# 5. 说说原型链
用来拓展对象属性的篮子，存在的意义是节省对象创建时的属性数据共享，解决内存空间,本质是一个对象
1. 既然本质是对象,并且是在方法声明的时候已经存在了,所以当实例化两个对象实例时候,数据是共享的。
2. 常规情况下，任何方法都有prototype属性,是继承Object.prototype,方法有prototype对象有__proto__
3. Function函数是所有对象创建的源头，它属于内建函数，所以Function.prototype等于它本身
4. Object.prototype是所有原型链的终点，因为Object.prototype.__proto__值为null

# 6.说下worker
1. 为 JavaScript 创造多线程环境 ---更加充分发挥客户端的CPU资源 并不是 内存，磁盘IO，网络
2. 子线程不能再创建子进程，线程之间通过onmessage，postMessage传递参数，通过terminate关闭线程
3. 同源限制，与调用者主线程同源
4. dom限制，只有简单的navigator对象，seTimeout,setInterval,XMLHttpRequers这几种api

# 7.说下缓存
1. 缓存主要包括HTTP缓存和浏览器缓存
2. http缓存有Cache-Control    Expires    Etag/If-None-Match    last-Modified/If-Modified-Since
3. 浏览器缓存    Cookie    WebStorage(localStorage/SessionStorage)    WebSql    IndexDB  Application Cache    service work


# 8.说下wpa
1. 存在的意义是为了解决应用的性能和弱网情况下的体验
2. 通过manifest文件来注册缓存的静态资源，将文件通过是否缓存进行分类，构建APP骨架，用service worker来进行缓存，基于web worker的方式进行控制
3. 原理是后台线程，独立于当前网页线程，网络代理：在网页发送请求时代理，缓存文件，一些网站启用了service worker会在size哪里来源service Worker
4. 因为涉及到请求拦截，所以使用条件是必须用https协议来保障安全。
5. 注册--安装--激活--更新(需要等待原始版本terminated)--idele--fetch
6. google推出的第三方库workbox

# 9.怎么理解模块化
1. 全局污染，早期的脚本会照成全局污染的问题
2. 模块Namespace模式，用对象方法模式解决全局污染的问题  会任意修改和删除属性和值
3. IIFE匿名闭包    解决命名冲突问题，用适配器模式选择性的暴露方法和变量，问题增加了书写难度，相互调用
4. 请求过多，依赖模糊，难以维护，
5. 通过模块化的规范 让脚本，避免命名冲突，更好分离，按需加载，复用性高，可维护性
6. CommonJS规范   node层   Browserify[ˈbraʊzər]可以让这个规范运行到浏览器端，在node v8.5.0以上的版本开始支持es6的modules
7. AMD规范   专门用于浏览器端, 模块的加载是异步的预执行  require.js
8. CMD规范    淘宝玉伯出的，推荐就近依赖原则懒执行，seajs
9. ES6规范modules规范
10. 再到今天的webpack工程化，webpack本身是用node写的遵循的是commonJS规范，vue遵循的是es6规范
11. 相信后面都会被es6收编，当然没有AMD和CMD和CommonJS的推动模块化，CDMA的标准规范也不会这么快落地。

# 10. 跨域
1. cros
2. proxy   http-proxy-middleware
3. nginx


# webpack性能优化
webpack  开发优化:hardSource  happypack(多线程打包)   生成优化： tree shaking  分包

# 同构ssr
1. 初始化应清单 - 通过vue-server-rendererVue提供的webpack插件，将webpack以客户端和服务端两个入口形式打包，打包后生成对应客户端服务端所需要的资源清单
2. 请求处理 - 当客户端发送第一次请求时，node会拦截请求转发给vue-router，通过加载对应的资源列表
3. 后端渲染 - 运行服务端渲染初始化vue实例，根据当前url做路由匹配对应的组件，getMatchedComponents()，初始化一个asycData的选项(约定规范)，传入与当前页面匹配需要获取的异步数据,最后通过renderer.renderToString返回给页面
4. 数据返回 - 回到页面后运行entry-client.js等待路由onReady后执行挂载操作，这时候Vue实例和数据在客户端初始化一遍，但是asyncData的数据和vuex数据在服务端组装完毕后填充到页面，无需再次发送请求。
5. 总 - 第一次请求成功后，前端已经变成了一个SPA的单页应用，当再次访问其他页面的时候，当做spa应用渲染页面。

优化  FP  FMP  
1. 页面缓存  页脚微缓存  LRU  单位时间内同一个url会缓存掉
2. 组件缓存  serverCacheKey 配置对应的name
3. 接口缓存  cgi的数据做缓存策略
4. 代码优化，减少嵌套，减少首屏渲染量
5. 分块传输 renderToStream  加快FP的时间但是还是受限于cgi的数据拉取时间
6. 改造ssr算法  不用vue-loader  目的是以csr的形式加载  提前返回js和css 但是并不运行脚本，在entry-client中  写一个启动器 包裹js 等待cgi执行完成后在innerhtml  body并执行


# webpack
递归的方式解析每个文件，@babel/parser ,@babel/traverse    const { transformFromAst } = require("@babel/core");(@babel/preset-env)       localRequire
webpack的底层原理
1. 整体上是做递归，把js文件解析，入口文件名,文件依赖,代码code
2. 核心的话是一个paser文件，对每个文件内，通过 @bable/parser转化成功js的ast
3. 通过@babel/traverse 把每个文件的路径转化成相对入口文件的路径
4. 通过@babel/core的transformFromAst的转化为自己的js字符串,通过persets的属性通过preset-env的js标准降级处理
5. 生成这个三个key值的对象  来制作一个自动运行的生成器启动脚本，写入js文件。
6. 只运行的脚本通过require递归调用，在内层自己实现了一require,把对应的依赖传进去，通过eval运行code。


# http
请求行  消息报文 请求正文  无状态的 超文本传输协议
1. C->S 发送一个小的tcp,seq标记顺序，其中设置了一个SYN标记，标记是一个连接请求
2. S->C返回一个TCP，含有SYN和ACK标记位置，说明连接请求被接受
3. C->S 客户端想服务端发送一条确认信息，通知已经成功接收，在确认分组中携带ack发送数据
4. 每个收到的数据包都会向发送方发送ack确认

四次挥手
FIN：终止请求
C->S  FIN seq = x+2 ACK = y+1
S->C ACK x+3    服务端我知道了，响应客户端，防止客户端超时，半连接状态，
S->C FIN seq = y+1     服务器自己的活做完后才向客户端发送断开的请求，close()最后请求
C->S ACK y+2   拜拜

# https
1. C->S 发送https请求，返回公钥和证书
2. C->CA 证书证书询问证书的有效性，返回验证的结果
3. C->S 发送用公钥加密的数据给服务端，服务端收到数据后用私钥解密，这里采用的是非对称加密，通过一个ACE的算法生成一个随机数返回给客户端数据
4. 最后通过非对称加密的方式生成随机数，数据传输通过对称加密


# 项目选型

技术选型题目，基本可以参考cli工具的安装步骤
1. 端 项目是移动端 还是 PC端，因为需要考虑到使用那些技术栈，兼容到哪些端或浏览器
确认1的问题之后，就需要考虑下面的问题：
1. 库的选择，热门，成员技术水平
2. 资源处理   图片 字体 文件存储  oss  cdn
3. 项目分层   mvc  资源/配置/全局/工具/插件
4. css 样式处理，less，sass，postcss等
5. html处理，是否使用第三方的模板引擎
6. 开发流程规范 是否是多人协助，多人的话，需要制定开发规范，提交规范
7. 是否需要考虑SEO,需不需要服务端渲染
8. 优化：首屏加载、骨架屏、pwa、压缩等...

# koa  express

vue-router

compost  一个是返回上下文一个是  req res

# vue diff算法
同层比较

# vue的keep-aline 的底层  lru算法
https://blog.csdn.net/dongcehao/article/details/107050723

缓存的方式
1. 新数据插入到链表的头部
2. 每当缓存命中(即缓存数据被访问，则将数据转义到链表头部),
3. 如果没命中，或者链表满了，就将链表尾部的数据丢弃增加新的数据。
# nuxt项目经验
api模块的封装

nuxt有自动注入路由和vuex，没有对api的自动注入
需要自己写一个nuxt  模块的拓展，用来管理我的api并自动注入到我的nuxt上下文中
需要读取可配置的文件夹下的导出的网络请求的api方法，读取文件，支持深层次的读取，序列化成

# 中台
graphQL:可以查询多种数据库的查询语言
postgREST:serve 自动生成增删改查的api


# toB和toC的区别

# 安全
- xss 跨站脚本攻击  转义  
   - set("X-XSS-Protection",1)  
   - ctx.set("Content-Security-Policy","deault-src 'self'")
   - set("Set-Cookie","uid112;Path/;HttpOnly")
- csrf   跨站请求伪造
  - referer判断请求来源
  - 验证码  比较常用
  - cookie值进行hash  双重校验
- 点击劫持
  - x-frame-options  不运行iframe产生
    - edny  不允许
    - sameorigin  同域
    - allowfrom   表示页面可以在指定来源的iframe中展示
- sql注入
  - 占位符
- DNS劫持
- HTTP劫持
- DDOS流量攻击
  - cc攻击   服务商  协助  加带宽  黑洞等

-https 中间人攻击


# vue3.0新特性
1. 性能上提升
   1. update性能高提升1.3-2倍  其实比较保守
   2. SSR速度提升2-3倍
   3. 编译标记  pathUpdate 位运算符枚举  时间缓存
2. Tree shaking
   1. 按需引入，包体积更小
3. composition api
   1. 与现有的 Options API一起使用
   2. 灵活组合
4. fargment Teleport Suspense
   1. 不再限于末班中需要根节点
   2. telport  响应式设计，在什么尺寸下隐藏和展开
   3. suspense 异步组件的实现
5. 更快的ts
   1. 配合vite
6. Custom Renderer API：暴露了自定义渲染API
   1. 把compile层暴露出去，可以做中间层。

# 函数式编程
来源于范畴式的一个数学分支，使用剪头连接物体，是一个编程思想

纯函数，表述值的变化，无状态，无副作用,引用透明

代码上的体现
组合
高阶函数
柯理化

# 测试
jest 单元测试  测试集
e2e 测试用例
1. 为了让系统更加健壮性，也方便后期维护
2. 保证单一功能修改，不会影响其他代码
3. 方便写测试用例的代码才是好代码，因为单一原则，考虑的边界相对少。
常规  项目核心业务会写测试用例，保证覆盖率


# node在实际项目中的使用
搭建一个node项目需要准备
1. 选择合适的框架 egg  koa  express
2. 静态文件
3. 路由
4. 参数接收  文件 koa-bodyparser
5. 数据验证  egg-validate
6. 日志
7. 权限  jwt jsonwebtoken redis
8. ejs
9. resful  helpr.js  接收风格和返回风格
10. orm框架  sequelize mysql2  mongoose
11. 配置文件  数据库配置文件，返回的提示语句控制



# mongo
是由c++语言 编写的，分布式文件存储的开源数据库系统，存储的格式，类似json的bjson（二进制json）
优点：
1. 高性能，嵌入式的数据模型减少IO操作，数据灵活，2-3k的qps
2. 语言查询 - 丰富的语言查询，支持丰富的查询语言来支持CRUD以及数据汇总，文本搜索和地理空间索引
3. 水平拓展：迁移部分
4. 多种存储引擎

使用情况  应用服务器的日志记录
No schema 新增字段不用改表结构  学习成本极低

只支持单表事务控制，4.0版本支持全DB
多备用节点

# 如何操作mongoose数据库
1. 创建 Schema  可定义校验规则
2. 添加 create
3. 查询 find
4. 更新 updateOne
5. 删除 deleteOne

graphql
数据查询语言
优点：增加了数据层接口的灵活组装。
schaema数据定义
resolver相当于controller也就是处理函数，query并行，mutation串行
GraphQL Playground 提供文档服务功能
apollo


# redis
字符串 string
哈希    hash
列表    list
集合    set
有序集合    zset


# 陌生单词
- unhandledrejection
- stopPropagation
- preventDefault
- prototype
- defineProperty
- configurable
- enumerable
- writable
- RexExp
- manifest
- terminated
- Expires
- If-Modified-Since
- If-None-Match
- http-proxy-middleware
- withCredentials
- MutationObserver
- setImmediate
- InterSectionObserver  无限滚动的api
- protocol 协议
- Authorization
- node-inspector
- puppeteer
- requestIdleCallback
- deadline.timeRemaining